{% extends "minimal.html" %}

{% block title %}å¬å†™å¡ç‰‡ - {{ title }}{% endblock %}

{% block scripts %}
{{ super() }}
<script>
class ListenMode {
    constructor() {
        this.cards = document.querySelectorAll('.card');
        this.currentIndex = 0;
        this.cardMarks = new Map(); // å­˜å‚¨å¡ç‰‡æ ‡è®°çŠ¶æ€
        this.isListening = false;
        this.settings = {
            repeatCount: 2,
            contentSide: 'front',
            cardOrder: 'sequential',
            autoNext: true,
            showProgress: false,
            voiceLanguage: 'auto'
        };
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.loadSettings();
        this.showCard(0);
        this.updateProgress();
        
        // è®¾ç½®å½“å‰æ—¥æœŸ
        const dateElement = document.querySelector('.date-info');
        if (dateElement && !dateElement.textContent.includes('ä»Šå¤©')) {
            const today = new Date().toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                weekday: 'long'
            });
            dateElement.innerHTML = `ğŸ“… ${today}`;
        }
    }
    
    bindEvents() {
        // æ§åˆ¶æŒ‰é’®äº‹ä»¶
        document.getElementById('prev-button').addEventListener('click', () => this.prevCard());
        document.getElementById('next-button').addEventListener('click', () => this.nextCard());
        document.getElementById('play-button').addEventListener('click', () => this.playCard());
        
        // æ ‡è®°æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.mark-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const mark = e.target.dataset.mark;
                this.markCard(this.currentIndex, mark);
            });
        });
        
        // è®¾ç½®å˜æ›´äº‹ä»¶
        document.getElementById('repeat-count').addEventListener('change', (e) => {
            this.settings.repeatCount = parseInt(e.target.value);
        });
        
        document.getElementById('content-side').addEventListener('change', (e) => {
            this.settings.contentSide = e.target.value;
        });
        
        document.getElementById('card-order').addEventListener('change', (e) => {
            this.settings.cardOrder = e.target.value;
            this.reorderCards();
        });
        
        document.getElementById('auto-next').addEventListener('change', (e) => {
            this.settings.autoNext = e.target.checked;
        });
        
        document.getElementById('show-progress').addEventListener('change', (e) => {
            this.settings.showProgress = e.target.checked;
            this.toggleProgressDisplay();
        });
        
        document.getElementById('voice-language').addEventListener('change', (e) => {
            this.settings.voiceLanguage = e.target.value;
        });
        
        // å¯¼å‡ºæŠ¥å‘Šäº‹ä»¶
        document.getElementById('export-report').addEventListener('click', () => this.exportReport());
        
        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
    }
    
    loadSettings() {
        // ä»localStorageåŠ è½½è®¾ç½®
        const saved = localStorage.getItem('listenModeSettings');
        if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
            this.applySettings();
        }
    }
    
    saveSettings() {
        localStorage.setItem('listenModeSettings', JSON.stringify(this.settings));
    }
    
    applySettings() {
        document.getElementById('repeat-count').value = this.settings.repeatCount;
        document.getElementById('content-side').value = this.settings.contentSide;
        document.getElementById('card-order').value = this.settings.cardOrder;
        document.getElementById('auto-next').checked = this.settings.autoNext;
        document.getElementById('show-progress').checked = this.settings.showProgress;
        document.getElementById('voice-language').value = this.settings.voiceLanguage;
    }
    
    showCard(index) {
        // éšè—æ‰€æœ‰å¡ç‰‡
        this.cards.forEach(card => card.classList.remove('active'));
        
        // æ˜¾ç¤ºå½“å‰å¡ç‰‡
        if (this.cards[index]) {
            this.cards[index].classList.add('active');
            this.currentIndex = index;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('prev-button').disabled = index === 0;
            document.getElementById('next-button').disabled = index === this.cards.length - 1;
            
            // åœæ­¢å½“å‰æ’­æ”¾çš„éŸ³é¢‘
            if (this.isListening) {
                window.speechSynthesis.cancel();
                this.isListening = false;
                const playButton = document.getElementById('play-button');
                playButton.textContent = 'ğŸ”Š æ’­æ”¾';
                playButton.disabled = false;
                // ç§»é™¤æ‰€æœ‰å¡ç‰‡çš„listeningçŠ¶æ€
                this.cards.forEach(card => card.classList.remove('listening'));
            }
        }
    }
    
    prevCard() {
        if (this.currentIndex > 0) {
            this.showCard(this.currentIndex - 1);
        }
    }
    
    nextCard() {
        if (this.currentIndex < this.cards.length - 1) {
            this.showCard(this.currentIndex + 1);
        }
    }
    
    async playCard() {
        if (this.isListening) return;
        
        const currentCard = this.cards[this.currentIndex];
        const playButton = document.getElementById('play-button');
        
        this.isListening = true;
        currentCard.classList.add('listening');
        playButton.textContent = 'â¸ï¸ åœæ­¢';
        playButton.disabled = true;
        
        try {
            // è·å–è¦æ’­æ”¾çš„å†…å®¹
            let content = '';
            const frontContent = currentCard.querySelector('.card-front .card-content').textContent.trim();
            const backContent = currentCard.querySelector('.card-back .card-content').textContent.trim();
            
            switch (this.settings.contentSide) {
                case 'front':
                    content = frontContent;
                    break;
                case 'back':
                    content = backContent;
                    break;
                case 'both':
                    content = `${frontContent}ã€‚${backContent}`;
                    break;
            }
            
            // ä½¿ç”¨Web Speech APIæ’­æ”¾
            for (let i = 0; i < this.settings.repeatCount; i++) {
                await this.speak(content);
                if (i < this.settings.repeatCount - 1) {
                    await this.delay(500); // é‡å¤é—´éš”
                }
            }
            
            // è‡ªåŠ¨ä¸‹ä¸€å¼ 
            if (this.settings.autoNext && this.currentIndex < this.cards.length - 1) {
                await this.delay(1000);
                this.nextCard();
            }
            
        } catch (error) {
            console.error('æ’­æ”¾å¤±è´¥:', error);
            alert('æ’­æ”¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½');
        } finally {
            this.isListening = false;
            currentCard.classList.remove('listening');
            playButton.textContent = 'ğŸ”Š æ’­æ”¾';
            playButton.disabled = false;
        }
    }
    
    speak(text) {
        return new Promise((resolve, reject) => {
            if (!window.speechSynthesis) {
                reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ'));
                return;
            }

            // æ£€æµ‹è¯­è¨€å¹¶è®¾ç½®ç›¸åº”çš„è¯­éŸ³
            const utterance = new SpeechSynthesisUtterance(text);
            
            // æ ¹æ®è®¾ç½®é€‰æ‹©è¯­è¨€
            if (this.settings.voiceLanguage === 'auto') {
                // æ™ºèƒ½è¯­è¨€æ£€æµ‹
                if (/[\u4e00-\u9fff]/.test(text)) {
                    // åŒ…å«ä¸­æ–‡å­—ç¬¦
                    utterance.lang = 'zh-CN';
                } else if (/[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(text)) {
                    // åŒ…å«æ—¥æ–‡å­—ç¬¦
                    utterance.lang = 'ja-JP';
                } else {
                    // é»˜è®¤è‹±æ–‡
                    utterance.lang = 'en-US';
                }
            } else {
                // ä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„è¯­è¨€
                utterance.lang = this.settings.voiceLanguage;
            }
            
            // ä¼˜åŒ–æ’­æ”¾å‚æ•°
            utterance.rate = 1.0;  // æé«˜æ’­æ”¾é€Ÿåº¦
            utterance.pitch = 1.0;
            utterance.volume = 0.9;
            
            utterance.onend = () => {
                resolve();
            };
            
            utterance.onerror = (event) => {
                reject(new Error(`è¯­éŸ³æ’­æ”¾å¤±è´¥: ${event.error}`));
            };
            
            // æ¸…é™¤ä¹‹å‰çš„è¯­éŸ³é˜Ÿåˆ—ï¼Œç¡®ä¿æµç•…æ’­æ”¾
            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(utterance);
        });
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    markCard(index, mark) {
        const cardId = this.cards[index].id || `card-${index}`;
        const previousMark = this.cardMarks.get(cardId);
        
        // æ›´æ–°æ ‡è®°
        this.cardMarks.set(cardId, {
            mark: mark,
            timestamp: new Date().toISOString(),
            cardIndex: index
        });
        
        // è§†è§‰åé¦ˆ
        const currentCard = this.cards[index];
        currentCard.classList.remove('marked-familiar', 'marked-vague', 'marked-forgotten');
        currentCard.classList.add(`marked-${mark}`);
        
        // æ›´æ–°è¿›åº¦ç»Ÿè®¡
        this.updateProgress();
        
        // æ˜¾ç¤ºæ ‡è®°åé¦ˆ
        this.showMarkFeedback(mark);
        
        // è‡ªåŠ¨ä¸‹ä¸€å¼ ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if (this.settings.autoNext && index < this.cards.length - 1) {
            setTimeout(() => this.nextCard(), 800);
        }
    }
    
    showMarkFeedback(mark) {
        const messages = {
            familiar: 'âœ… å·²æ ‡è®°ä¸ºç†Ÿæ‚‰',
            vague: 'â“ å·²æ ‡è®°ä¸ºæ¨¡ç³Š',
            forgotten: 'âŒ å·²æ ‡è®°ä¸ºå¿˜è®°'
        };
        
        // åˆ›å»ºä¸´æ—¶æç¤º
        const feedback = document.createElement('div');
        feedback.className = 'mark-feedback';
        feedback.textContent = messages[mark];
        feedback.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 1rem;
            z-index: 2000;
            animation: fadeInOut 1.5s ease-in-out;
        `;
        
        document.body.appendChild(feedback);
        setTimeout(() => feedback.remove(), 1500);
    }
    
    updateProgress() {
        const stats = { familiar: 0, vague: 0, forgotten: 0, unmarked: 0 };
        
        // ç»Ÿè®¡å„ç§æ ‡è®°
        for (let i = 0; i < this.cards.length; i++) {
            const cardId = this.cards[i].id || `card-${i}`;
            const mark = this.cardMarks.get(cardId);
            
            if (mark) {
                stats[mark.mark]++;
            } else {
                stats.unmarked++;
            }
        }
        
        // æ›´æ–°æ˜¾ç¤º
        document.getElementById('familiar-count').textContent = stats.familiar;
        document.getElementById('vague-count').textContent = stats.vague;
        document.getElementById('forgotten-count').textContent = stats.forgotten;
        document.getElementById('unmarked-count').textContent = stats.unmarked;
    }
    
    reorderCards() {
        // æ ¹æ®è®¾ç½®é‡æ–°æ’åºå¡ç‰‡
        const cardArray = Array.from(this.cards);
        let orderedCards = [];
        
        switch (this.settings.cardOrder) {
            case 'sequential':
                orderedCards = cardArray;
                break;
            case 'random':
                orderedCards = this.shuffleArray([...cardArray]);
                break;
            case 'marked-first':
                // ä¼˜å…ˆæ˜¾ç¤ºå·²æ ‡è®°çš„å¡ç‰‡
                const marked = cardArray.filter(card => {
                    const cardId = card.id || `card-${Array.from(this.cards).indexOf(card)}`;
                    return this.cardMarks.has(cardId);
                });
                const unmarked = cardArray.filter(card => {
                    const cardId = card.id || `card-${Array.from(this.cards).indexOf(card)}`;
                    return !this.cardMarks.has(cardId);
                });
                orderedCards = [...marked, ...unmarked];
                break;
        }
        
        // é‡æ–°æ’åˆ—DOMå…ƒç´ 
        const container = document.getElementById('cardGrid');
        orderedCards.forEach(card => container.appendChild(card));
        
        // æ›´æ–°cardsæ•°ç»„
        this.cards = document.querySelectorAll('.card');
        this.showCard(0);
    }
    
    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    toggleProgressDisplay() {
        const progressInfo = document.querySelector('.progress-info');
        if (this.settings.showProgress) {
            progressInfo.style.display = 'block';
        } else {
            progressInfo.style.display = 'none';
        }
    }
    
    exportReport() {
        const reportData = [];
        const timestamp = new Date().toISOString();
        
        // æ”¶é›†æ‰€æœ‰å¡ç‰‡æ•°æ®
        for (let i = 0; i < this.cards.length; i++) {
            const card = this.cards[i];
            const cardId = card.id || `card-${i}`;
            const mark = this.cardMarks.get(cardId);
            
            const frontContent = card.querySelector('.card-front .card-content').textContent.trim();
            const backContent = card.querySelector('.card-back .card-content').textContent.trim();
            const tags = card.dataset.tags || '';
            
            reportData.push({
                'å¡ç‰‡ç¼–å·': i + 1,
                'æ­£é¢å†…å®¹': frontContent,
                'èƒŒé¢å†…å®¹': backContent,
                'æ ‡ç­¾': tags,
                'æ ‡è®°çŠ¶æ€': mark ? mark.mark : 'æœªæ ‡è®°',
                'æ ‡è®°æ—¶é—´': mark ? mark.timestamp : '',
                'å¯¼å‡ºæ—¶é—´': timestamp
            });
        }
        
        // ç”ŸæˆCSV
        const csv = this.generateCSV(reportData);
        
        // ä¸‹è½½æ–‡ä»¶
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `å¬å†™æŠ¥å‘Š_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        alert('ğŸ“Š å¬å†™æŠ¥å‘Šå·²å¯¼å‡ºæˆåŠŸï¼');
    }
    
    generateCSV(data) {
        if (data.length === 0) return '';
        
        const headers = Object.keys(data[0]);
        const csvContent = [
            headers.join(','),
            ...data.map(row => 
                headers.map(header => {
                    const value = String(row[header] || '');
                    // å¤„ç†åŒ…å«é€—å·æˆ–å¼•å·çš„å€¼
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(',')
            )
        ].join('\n');
        
        // æ·»åŠ BOMä»¥æ”¯æŒä¸­æ–‡
        return '\ufeff' + csvContent;
    }
    
    handleKeyboard(e) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        
        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                this.prevCard();
                break;
            case 'ArrowRight':
                e.preventDefault();
                this.nextCard();
                break;
            case ' ':
                e.preventDefault();
                this.playCard();
                break;
            case '1':
                e.preventDefault();
                this.markCard(this.currentIndex, 'familiar');
                break;
            case '2':
                e.preventDefault();
                this.markCard(this.currentIndex, 'vague');
                break;
            case '3':
                e.preventDefault();
                this.markCard(this.currentIndex, 'forgotten');
                break;
        }
    }
}

// æ·»åŠ æ ‡è®°æ ·å¼
const markStyles = document.createElement('style');
markStyles.textContent = `
    .card.marked-familiar {
        border: 3px solid #28a745;
        box-shadow: 0 0 15px rgba(40, 167, 69, 0.3);
    }
    
    .card.marked-vague {
        border: 3px solid #ffc107;
        box-shadow: 0 0 15px rgba(255, 193, 7, 0.3);
    }
    
    .card.marked-forgotten {
        border: 3px solid #dc3545;
        box-shadow: 0 0 15px rgba(220, 53, 69, 0.3);
    }
    
    @keyframes fadeInOut {
        0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
`;
document.head.appendChild(markStyles);

// åˆå§‹åŒ–å¬å†™æ¨¡å¼
document.addEventListener('DOMContentLoaded', () => {
    window.listenMode = new ListenMode();
});
</script>
{% endblock %}

{% block page_styles %}
{{ super() }}
<style>
    /* é¡µé¢æ•´ä½“å¸ƒå±€ */
    body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
    }

    .main-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        margin-top: 20px;
        margin-bottom: 20px;
        min-height: calc(100vh - 40px);
    }

    /* é¡µé¢æ ‡é¢˜åŒºåŸŸ */
    .page-header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        color: white;
    }

    .page-header h1 {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 10px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .page-header .date-info {
        font-size: 1rem;
        opacity: 0.9;
        margin-bottom: 5px;
    }

    .page-header .card-count {
        font-size: 0.9rem;
        opacity: 0.8;
    }

    /* è®¾ç½®é¢æ¿ */
    .settings-panel {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        border: 1px solid #e9ecef;
    }

    .settings-title {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #495057;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
    }

    .setting-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .setting-group label {
        font-size: 0.9rem;
        font-weight: 500;
        color: #6c757d;
    }

    .setting-group select,
    .setting-group input[type="number"] {
        padding: 8px 12px;
        border: 1px solid #ced4da;
        border-radius: 6px;
        font-size: 0.9rem;
        background: white;
    }

    .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 5px;
    }

    .checkbox-group input[type="checkbox"] {
        width: 16px;
        height: 16px;
    }

    /* å¡ç‰‡æ˜¾ç¤ºåŒºåŸŸ */
    .card-display-area {
        display: flex;
        gap: 30px;
        align-items: flex-start;
    }

    .card-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 400px;
        position: relative;
        gap: 20px;
    }

    .flashcard-grid {
        display: block;
        width: 100%;
        max-width: 400px;
    }

    .card {
        margin: 0 auto;
        display: none;
        width: 74.25mm;
        height: 105mm;
    }

    .card.active {
        display: block;
    }

    /* å¡ç‰‡æ ‡è®°é¢æ¿ */
    .marking-panel {
        width: 250px;
        background: #f8f9fa;
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #e9ecef;
        height: fit-content;
    }

    .marking-title {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #495057;
        text-align: center;
    }

    .marking-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .mark-button {
        padding: 12px 16px;
        border: none;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    .mark-button.familiar {
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
    }

    .mark-button.vague {
        background: linear-gradient(135deg, #ffc107, #fd7e14);
        color: white;
    }

    .mark-button.forgotten {
        background: linear-gradient(135deg, #dc3545, #e83e8c);
        color: white;
    }

    .mark-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .progress-info {
        margin-top: 20px;
        padding: 15px;
        background: white;
        border-radius: 8px;
        border: 1px solid #dee2e6;
    }

    .progress-info h4 {
        font-size: 0.9rem;
        margin-bottom: 10px;
        color: #495057;
    }

    .progress-stats {
        display: flex;
        flex-direction: column;
        gap: 5px;
        font-size: 0.8rem;
    }

    .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .stat-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 5px;
    }

    /* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */
    .listen-controls {
        display: flex;
        gap: 12px;
        justify-content: center;
        background: rgba(255, 255, 255, 0.95);
        padding: 12px 24px;
        border-radius: 30px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .listen-controls button {
        padding: 10px 18px;
        font-size: 0.9em;
        font-weight: 500;
        border: none;
        border-radius: 22px;
        cursor: pointer;
        background: linear-gradient(135deg, var(--primary-color), #2980b9);
        color: white;
        transition: all 0.3s ease;
        min-width: 90px;
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    .listen-controls button:hover {
        background: linear-gradient(135deg, #2980b9, #1f5f8b);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
    }

    /* å¯¼å‡ºæŒ‰é’® */
    .export-button {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        border: none;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1000;
    }

    .export-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
    }

    /* å¬å†™çŠ¶æ€æŒ‡ç¤º */
    .listen-status {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 1em;
        font-weight: 500;
        display: none;
        z-index: 100;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card.listening .card-content {
        opacity: 0.2;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    .card.listening .listen-status {
        display: block;
        animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
        .main-container {
            margin: 10px;
            padding: 15px;
        }

        .card-display-area {
            flex-direction: column;
            gap: 20px;
        }

        .marking-panel {
            width: 100%;
        }

        .settings-grid {
            grid-template-columns: 1fr;
        }

        .export-button {
            position: static;
            margin-bottom: 20px;
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block body_content %}
<div class="main-container">
    <!-- é¡µé¢æ ‡é¢˜ -->
    <div class="page-header">
        <h1>ğŸ“š å¬å†™ç»ƒä¹ </h1>
        <div class="date-info">ğŸ“… {{ current_date or "ä»Šå¤©" }}</div>
        <div class="card-count">ğŸ“Š å…± <span id="total-cards">{{ cards|length }}</span> å¼ å¡ç‰‡</div>
    </div>

    <!-- è®¾ç½®é¢æ¿ -->
    <div class="settings-panel">
        <div class="settings-title">
            âš™ï¸ å¬å†™è®¾ç½®
        </div>
        <div class="settings-grid">
            <div class="setting-group">
                <label for="repeat-count">é‡å¤æ¬¡æ•°</label>
                <select id="repeat-count">
                    <option value="1">1æ¬¡</option>
                    <option value="2" selected>2æ¬¡</option>
                    <option value="3">3æ¬¡</option>
                    <option value="4">4æ¬¡</option>
                    <option value="5">5æ¬¡</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="content-side">å¬å†™å†…å®¹</label>
                <select id="content-side">
                    <option value="front" selected>æ­£é¢å†…å®¹</option>
                    <option value="back">èƒŒé¢å†…å®¹</option>
                    <option value="both">æ­£é¢+èƒŒé¢</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="card-order">å¡ç‰‡é¡ºåº</label>
                <select id="card-order">
                    <option value="sequential" selected>æŒ‰é¡ºåº</option>
                    <option value="random">éšæœºé¡ºåº</option>
                    <option value="marked-first">æ ‡è®°çš„ä¼˜å…ˆ</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="voice-language">è¯­éŸ³è¯­è¨€</label>
                <select id="voice-language">
                    <option value="auto" selected>è‡ªåŠ¨æ£€æµ‹</option>
                    <option value="zh-CN">ä¸­æ–‡ (æ™®é€šè¯)</option>
                    <option value="en-US">è‹±è¯­ (ç¾å¼)</option>
                    <option value="en-GB">è‹±è¯­ (è‹±å¼)</option>
                    <option value="ja-JP">æ—¥è¯­</option>
                    <option value="ko-KR">éŸ©è¯­</option>
                    <option value="fr-FR">æ³•è¯­</option>
                    <option value="de-DE">å¾·è¯­</option>
                    <option value="es-ES">è¥¿ç­ç‰™è¯­</option>
                </select>
            </div>
            <div class="setting-group">
                <label>å…¶ä»–é€‰é¡¹</label>
                <div class="checkbox-group">
                    <input type="checkbox" id="auto-next" checked>
                    <label for="auto-next">è‡ªåŠ¨ä¸‹ä¸€å¼ </label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="show-progress">
                    <label for="show-progress">æ˜¾ç¤ºè¿›åº¦</label>
                </div>
            </div>
        </div>
    </div>

    <!-- å¡ç‰‡æ˜¾ç¤ºå’Œæ ‡è®°åŒºåŸŸ -->
    <div class="card-display-area">
        <!-- å¡ç‰‡å®¹å™¨ -->
        <div class="card-container">
            <div class="flashcard-grid" id="cardGrid">
                {% for card in cards %}
                <div class="card" id="{{ card.id }}" data-tags="{{ card.tags|join(',') }}" data-index="{{ loop.index0 }}">
                    <div class="card-inner">
                        <div class="card-front">
                            <div class="deck-name">{{ title }}</div>
                            <div class="card-index">{{ loop.index }}/{{ cards|length }}</div>
                            <div class="card-content">
                                {{ card.front|safe }}
                            </div>
                        </div>
                        <div class="card-back">
                            <div class="card-index">{{ loop.index }}/{{ cards|length }}</div>
                            <div class="card-content">
                                {{ card.back|safe }}
                            </div>
                        </div>
                    </div>
                    <!-- å¬å†™çŠ¶æ€æŒ‡ç¤º -->
                    <div class="listen-status" id="listen-status-{{ loop.index0 }}">
                        æ­£åœ¨æ’­æ”¾...
                    </div>
                </div>
                {% endfor %}
            </div>
            
            <!-- å¬å†™æ§åˆ¶æŒ‰é’® - ç§»åˆ°å¡ç‰‡æ­£ä¸‹æ–¹ -->
            <div class="listen-controls">
                <button id="prev-button">â¬…ï¸ ä¸Šä¸€å¼ </button>
                <button id="play-button">ğŸ”Š æ’­æ”¾</button>
                <button id="next-button">â¡ï¸ ä¸‹ä¸€å¼ </button>
            </div>
        </div>

        <!-- å¡ç‰‡æ ‡è®°é¢æ¿ -->
        <div class="marking-panel">
            <div class="marking-title">ğŸ“ å¡ç‰‡æ ‡è®°</div>
            <div class="marking-buttons">
                <button class="mark-button familiar" data-mark="familiar">
                    âœ… ç†Ÿæ‚‰
                </button>
                <button class="mark-button vague" data-mark="vague">
                    â“ æ¨¡ç³Š
                </button>
                <button class="mark-button forgotten" data-mark="forgotten">
                    âŒ å¿˜è®°
                </button>
            </div>
            
            <div class="progress-info">
                <h4>ğŸ“Š å­¦ä¹ è¿›åº¦</h4>
                <div class="progress-stats">
                    <div class="stat-item">
                        <span><span class="stat-color" style="background: #28a745;"></span>ç†Ÿæ‚‰</span>
                        <span id="familiar-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span><span class="stat-color" style="background: #ffc107;"></span>æ¨¡ç³Š</span>
                        <span id="vague-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span><span class="stat-color" style="background: #dc3545;"></span>å¿˜è®°</span>
                        <span id="forgotten-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span><span class="stat-color" style="background: #6c757d;"></span>æœªæ ‡è®°</span>
                        <span id="unmarked-count">{{ cards|length }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- å¯¼å‡ºæŒ‰é’® -->
<button class="export-button" id="export-report">
    ğŸ“Š å¯¼å‡ºæŠ¥å‘Š
</button>
{% endblock %}